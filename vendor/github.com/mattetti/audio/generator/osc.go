package generator

import (
	"errors"
	"fmt"
	"math"

	"github.com/mattetti/audio"
)

// Osc is an oscillator
type Osc struct {
	Shape     WaveType
	Amplitude float64
	DcOffset  float64
	Freq      float64
	// SampleRate
	Fs                int
	PhaseOffset       float64
	CurrentPhaseAngle float64
	phaseAngleIncr    float64
	// currentSample allows us to track where we are at in the signal life
	// and setup an envelope accordingly
	currentSample int
	// ADSR
	attackInSamples int
}

// NewOsc returns a new oscillator, note that if you change the phase offset of the returned osc,
// you also need to set the CurrentPhaseAngle
func NewOsc(shape WaveType, hz float64, fs int) *Osc {
	return &Osc{Shape: shape, Amplitude: 1, Freq: hz, Fs: fs, phaseAngleIncr: ((hz * TwoPi) / float64(fs))}
}

// Reset sets the oscillator back to its starting state
func (o *Osc) Reset() {
	o.phaseAngleIncr = ((o.Freq * TwoPi) / float64(o.Fs))
	o.currentSample = 0
}

// SetFreq updates the oscillator frequency
func (o *Osc) SetFreq(hz float64) {
	if o.Freq != hz {
		o.Freq = hz
		o.phaseAngleIncr = ((hz * TwoPi) / float64(o.Fs))
	}
}

// SetAttackInMs sets the duration for the oscillator to be at full amplitude
// after it starts.
func (o *Osc) SetAttackInMs(ms int) {
	if o == nil {
		return
	}
	if ms <= 0 {
		o.attackInSamples = 0
		return
	}
	o.attackInSamples = int(float32(o.Fs) / (1000.0 / float32(ms)))
}

// Signal uses the osc to generate a discreet signal
func (o *Osc) Signal(length int) []float64 {
	output := make([]float64, length)
	for i := 0; i < length; i++ {
		output[i] = o.Sample()
	}
	return output
}

// Fill fills up the pass PCMBuffer with the output of the oscillator.
func (o *Osc) Fill(buf *audio.PCMBuffer) error {
	if o == nil {
		return nil
	}
	len := buf.Len()
	for i := 0; i < len; i++ {
		switch buf.DataType {
		case audio.Integer:
			buf.Ints[i] = int(o.Sample())
		case audio.Float:
			buf.Floats[i] = o.Sample()
		case audio.Byte:
			// TODO: check the format bitdepth and endianess and convert
			return errors.New("bytes buffer not yet supported")
		}
	}
	return nil
}

// Sample returns the next sample generated by the oscillator
func (o *Osc) Sample() (output float64) {
	if o == nil {
		return
	}
	o.currentSample++
	if o.CurrentPhaseAngle < -math.Pi {
		o.CurrentPhaseAngle += TwoPi
	} else if o.CurrentPhaseAngle > math.Pi {
		o.CurrentPhaseAngle -= TwoPi
	}

	var amp float64
	if o.attackInSamples > o.currentSample {
		// linear fade in
		amp = float64(o.currentSample) * (o.Amplitude / float64(o.attackInSamples))
	} else {
		amp = o.Amplitude
	}

	switch o.Shape {
	case WaveSine:
		output = amp*Sine(o.CurrentPhaseAngle) + o.DcOffset
	case WaveTriangle:
		output = amp*Triangle(o.CurrentPhaseAngle) + o.DcOffset
	case WaveSaw:
		output = amp*Sawtooth(o.CurrentPhaseAngle) + o.DcOffset
	case WaveSqr:
		fmt.Println(o.CurrentPhaseAngle)
		output = amp*Square(o.CurrentPhaseAngle) + o.DcOffset
	}

	o.CurrentPhaseAngle += o.phaseAngleIncr
	return output
}
